/*
   Copyright 2011-2012 StormMQ Limited

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */

#include "platform_limits.h"
#include "libamqp_common.h"

#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "Memory/Memory.h"
#include "Context/Context.h"
#include "Context/ErrorHandling.h"


#define SIZE_T_BYTES (sizeof(size_t))
static const size_t mask = (size_t) 0x996e796d586067caULL;      // generated by random.org

struct amqp__memory_block_t
{
    size_t count;
    size_t mask;
#if defined(LIBAMQP_DEBUG_ALLOCATIONS) || defined(LIBAMQP_DEBUG_DOUBLE_FREE)
    struct {
        struct {
            const  char *file_name;
            int line_number;
        } allocated_from;
#ifdef LIBAMQP_DEBUG_ALLOCATIONS
        amqp__memory_block_t **previous;
        amqp__memory_block_t *next;
#endif
#ifdef LIBAMQP_DEBUG_DOUBLE_FREE
        struct {
            const  char *file_name;
            int line_number;
        } freed_from;
#endif
    } debug;
#endif
    union {
        long double alignment_insurance;
        size_t fragments[2];
    } data;
};

#ifdef LIBAMQP_DEBUG_DOUBLE_FREE
static void debug_print(amqp__memory_block_t *block)
{
    printf("    Allocated from: %s(%d)\n", block->debug.allocated_from.file_name, block->debug.allocated_from.line_number);
    if (block->debug.freed_from.file_name)
    {
        printf("    Freed from: %s(%d)\n", block->debug.freed_from.file_name, block->debug.freed_from.line_number);
    }
}
#define LIBAMQP_TRAP_FN_DECL     amqp__memory_block_t *block
#define LIBAMQP_TRAP_FN_ARG      block
#else
#define debug_print(x)
#define LIBAMQP_TRAP_FN_DECL
#define LIBAMQP_TRAP_FN_ARG
#endif

static inline size_t byte_count_rounded_to_size_t_array_size(size_t n)
{
    return (n - 1) / SIZE_T_BYTES + 1;
}

static inline size_t calculate_bytes_to_allocate(size_t count)
{
    return sizeof(amqp__memory_block_t) + (count - 1) * SIZE_T_BYTES;
}

static inline void save_guard_mask(amqp__memory_block_t *block, size_t count)
{
    block->count = count;
    block->mask = mask;
    block->data.fragments[count] = mask ^ count;
}

void *amqp__malloc(amqp_context_t *context, size_t n AMQP_DEBUG_PARAMS_DECL)
{
    size_t count = byte_count_rounded_to_size_t_array_size(n);
    amqp__memory_block_t *block = (amqp__memory_block_t *) malloc(calculate_bytes_to_allocate(count));

#if defined(LIBAMQP_DEBUG_ALLOCATIONS) || defined(LIBAMQP_DEBUG_DOUBLE_FREE)
    block->debug.allocated_from.file_name = file_name;
    block->debug.allocated_from.line_number = line_number;
#ifdef LIBAMQP_DEBUG_ALLOCATIONS
    if (context)
    {
        if (context->memory.debug.allocated_blocks)
        {
            context->memory.debug.allocated_blocks->debug.previous = &block->debug.next;
        }

        // update new node
        block->debug.next = context->memory.debug.allocated_blocks;
        block->debug.previous = &context->memory.debug.allocated_blocks;

        // update list
        context->memory.debug.allocated_blocks = block;
    }
    else
    {
        block->debug.next = 0;
        block->debug.previous = 0;
    }
#endif
#ifdef LIBAMQP_DEBUG_DOUBLE_FREE
    block->debug.freed_from.file_name = 0;
    block->debug.freed_from.line_number = 0;
#endif
#endif

    if (context != 0)
    {
        context->memory.allocation_stats.outstanding_allocations++;
        context->memory.allocation_stats.total_allocation_calls++;
    }

    save_guard_mask(block, count);

    memset(&block->data.fragments[0], '\0', count * SIZE_T_BYTES);

    return &block->data.fragments[0];
}

// TODO - do something about fragmentation
void *amqp_malloc_array(amqp_context_t *context, size_t n, int count)
{
    return amqp_malloc(context, n * count);
}

static inline amqp__memory_block_t *calculate_block_start(void *p)
{
    static amqp__memory_block_t layout;

    return (amqp__memory_block_t *) ((unsigned char *) p - ((unsigned char *) &layout.data.fragments[0] - (unsigned char *) &layout.count));
}

void amqp_trap_leading_guard_corrupt(LIBAMQP_TRAP_FN_DECL)
{
}

static void assert_leading_guard_correct(amqp__memory_block_t *block)
{
    if (block->mask != mask)
    {
        amqp_trap_leading_guard_corrupt(LIBAMQP_TRAP_FN_ARG);
        printf("Start of block corrupt! Block: %p, mask: %lu - break on amqp_trap_leading_guard_corrupt() to debug.\n",
            (void *) block, (unsigned long) block->mask);
        debug_print(block);
        abort();
    }
}

void amqp_trap_trailing_guard_corrupt(LIBAMQP_TRAP_FN_DECL)
{
}

static void assert_trailing_guard_correct(amqp__memory_block_t *block)
{
    size_t count = block->count;
    if (block->data.fragments[count] != (mask ^ count))
    {
        amqp_trap_trailing_guard_corrupt(LIBAMQP_TRAP_FN_ARG);
        printf("End of block corrupt! Block: %p, count: %lu, block[count]: %lx - break on amqp_trap_trailing_guard_corrupt() to debug.\n",
            (void *) block, (unsigned long) count, (unsigned long) block->data.fragments[count]);
        debug_print(block);
        abort();
    }
}

void *amqp_realloc(amqp_context_t *context, const void *p, size_t n)
{
    amqp__memory_block_t *old_block = calculate_block_start((void *) p);
    size_t old_count;
    size_t count;
    amqp__memory_block_t *block;

    assert_leading_guard_correct(old_block);
    assert_trailing_guard_correct(old_block);

    old_count = old_block->count;
    count = byte_count_rounded_to_size_t_array_size(n);
    if (count <= old_count)
    {
        return (void *) p;
    }

    block = (amqp__memory_block_t *) realloc(old_block, calculate_bytes_to_allocate(count));

    memset(&block->data.fragments[old_count], '\0', (count - old_count) * SIZE_T_BYTES);

    if (context != 0)
    {
        context->memory.allocation_stats.total_allocation_calls++;
    }
    save_guard_mask(block, count);

    return &block->data.fragments[0];
}


#ifdef LIBAMQP_DEBUG_DOUBLE_FREE
void amqp_trap_double_free(LIBAMQP_TRAP_FN_DECL)
{
}
static void assert_no_prior_free(amqp__memory_block_t *block)
{
    if (block->debug.freed_from.file_name)
    {
        // amqp__free was already called for the block
        amqp_trap_double_free(LIBAMQP_TRAP_FN_ARG);
        printf("Repeated call to amqp_free()! Block: %p - break on amqp_trap_double_free() to debug.\n", (void *) block);
        debug_print(block);
        abort();
    }
}
#else
#define assert_no_prior_free(x)
#endif

void amqp__free(amqp_context_t *context, const void *p AMQP_DEBUG_PARAMS_DECL)
{
    amqp__memory_block_t *block;

    if (p)
    {
        block = calculate_block_start((void *) p);

        assert_no_prior_free(block);
        assert_leading_guard_correct(block);
        assert_trailing_guard_correct(block);

#ifdef LIBAMQP_DEBUG_DOUBLE_FREE
        block->debug.freed_from.file_name = file_name;
        block->debug.freed_from.line_number = line_number;
#endif
#ifdef LIBAMQP_DEBUG_ALLOCATIONS
        if (block->debug.previous)
        {
            *block->debug.previous = block->debug.next;
            if (block->debug.next)
            {
                block->debug.next->debug.previous = block->debug.previous;
            }
        }
#endif
        if (context != 0)
        {
            context->memory.allocation_stats.outstanding_allocations--;
        }
#ifndef LIBAMQP_DEBUG_DOUBLE_FREE
        free(block);
#endif
    }
}

void amqp_reset_malloc_allocation_stats()
{
    not_implemented(amqp_reset_malloc_allocation_stats);
}

char *amqp_duplicate(amqp_context_t *context, const char *data, size_t size)
{
    char *result = (char *) amqp_malloc(context, size);
    memcpy(result, data, size);
    return result;
}
char *amqp_duplicate_cstr(amqp_context_t *context, const char *s)
{
    return amqp_duplicate(context, s, strlen(s));
}

int amqp_check_allocation_count(amqp_context_t *context)
{
    int result = context->memory.allocation_stats.outstanding_allocations == 0;
    if (!result)
    {
#ifdef LIBAMQP_DEBUG_ALLOCATIONS
        amqp__memory_block_t *node = context->memory.debug.allocated_blocks;
        while (node)
        {
            const char *file_name = node->debug.allocated_from.file_name;
            int line_number = node->debug.allocated_from.line_number;
            node = node->debug.next;
            _amqp_error(context, 1, file_name, line_number, 0, amqp_error_mnemonic(AMQP_ERROR_BLOCK_NOT_FREED),
                    "Block allocated here is never dellocated.");
        }
#else
        amqp_error(context, AMQP_ERROR_MEMORY_ERROR,
            "Number of calls to malloc does not match numbers of calls to free - %d outstanding allocations.",
            context->memory.allocation_stats.outstanding_allocations);
#endif
    }
    return result;
}
